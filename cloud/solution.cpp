// Score: 22_876_544

/*

 --- THE MAIN IDEA ---
1. Sort VMs by number of CPUs in order to move VMs with big number of CPUs more
often.
2. Read current cpu usages.
3. Generate a few random VM reallocation candidates.
Each candidate is generated by this scheme: for each VM randomly choose server
to which it will be moved; If moving gives worse score than current server,
randomly choose another server and so on...
4. Choose a redistribution that costs less if left for eight hours.
5. Repeat 2-4 for each time point.

*/

#include <algorithm>
#include <assert.h>
#include <cmath>
#include <cstdlib>
#include <iostream>
#include <set>
#include <vector>

const int CPU_LIMIT = 300000; // = 10^6 * 30%

struct Server {
  int16_t total_cpu;
  int16_t free_cpu;
  int16_t free_ram;
  int16_t total_vms;
  int8_t penalties = 0;
  int64_t cpu_usage = 0;
};

struct VirtualServer {
  int cpu_usage = 0;
  int max_cpu_usage = 0;
  int16_t cpu;
  int16_t ram;
  int8_t home; // Server, where this VM is currently located
  int16_t id;  // Index of the VS, needed in order to sort without loosing info.
};

// Global variables for global information
int NUMBER_OF_SERVERS, NUMBER_OF_VMS, NUMBER_OF_TIME_POINTS;
// I never use current total penalty and I don't know why I keep track of it...
long double TOTAL_PENALTY = 0;
Server SERVERS[100];
VirtualServer VMS[10000];

// Custom random number generator, since I felt like std::rand() is slow
uint64_t fast_randint(void) {
  static uint64_t x = 123456789, y = 362436069, z = 521288629;
  uint64_t t;
  x ^= x << 16;
  x ^= x >> 5;
  x ^= x << 1;
  t = x, x = y, y = z;
  return z = t ^ x ^ y;
}

// Function to move one VM from one server to another and update a bunch of
// fields in global variable SERVERS.
inline std::pair<int, int> move_vm(int vm, int destination) {
  int source = VMS[vm].home;
  SERVERS[source].free_cpu += VMS[vm].cpu;
  SERVERS[source].free_ram += VMS[vm].ram;
  SERVERS[source].cpu_usage -= VMS[vm].cpu_usage;
  SERVERS[source].total_vms--;
  VMS[vm].home = destination;
  SERVERS[destination].free_cpu -= VMS[vm].cpu;
  SERVERS[destination].free_ram -= VMS[vm].ram;
  SERVERS[destination].cpu_usage += VMS[vm].cpu_usage;
  SERVERS[destination].total_vms++;
  TOTAL_PENALTY += VMS[vm].ram;
  return {VMS[vm].id + 1, destination + 1};
}

// Generate random VM reallocation
std::vector<int> get_relocation_candidate() {
  // Count number of moved VMs from or in the server in order to not move more
  // than two VMs per time point.
  int steps[100] = {};
  // Indexes for future servers to put the VMs
  std::vector<int> reallocations(NUMBER_OF_VMS);
  // Copy servers into local variable in order to not mess up global state.
  std::vector<Server> servers(NUMBER_OF_SERVERS);
  for (int i = 0; i < NUMBER_OF_SERVERS; i++)
    servers[i] = SERVERS[i];

  for (int i = 0; i < NUMBER_OF_VMS; i++) {
    // By default VM is not moved, so it stays in the same server as before
    // reallocation.
    reallocations[i] = VMS[i].home;
    // A few references in order to make make code more more concise
    auto &u = VMS[i];
    auto &srv = servers[u.home];
    // If home server already has two VMs moved or it is not overloaded, than
    // don't move VM out of it.
    if (steps[u.home] == 2 || srv.cpu_usage <= srv.total_cpu * CPU_LIMIT)
      continue;
    // Calculate maximum number of random destination candidates until give up
    // and don't move anything: 10^6 for real tests and 4 for sample test.
    int limit = NUMBER_OF_TIME_POINTS == 432 ? (int)1e6 / NUMBER_OF_VMS : 4;
    // Try to find destination by randomly choosing server until found or limit
    // is exceeded.
    for (int t = 0; t < limit; t++) {
      // Generate random destination server
      int j = fast_randint() % NUMBER_OF_SERVERS;
      auto &v = servers[j];
      // If destination server already has two VMs moved or it does not hold
      // enough RAM and CPUs in order to store our VM, than try another
      // destination candidate.
      if (u.home == j || steps[j] == 2 || v.free_cpu < u.cpu ||
          v.free_ram < u.ram)
        continue;
      // Check if we will exceed 30% of CPUs if all current VMs on this server
      // will be loaded on 100% and moved VM will be loaded on the same level as
      // maximum ever registed for that VM.
      int exceeds = (v.total_cpu - v.free_cpu) * 10 + u.max_cpu_usage / 100000 >
                    v.total_cpu * 3;
      // Calculate cost of destination server if current VM is moved there.
      int cost = exceeds ? (1 << v.penalties) * (v.total_vms + 1) : 0;
      // Don't move VM if it costs less to not move it.
      // P.S. this formula assumes that in both cases only one server gets
      // penalty -- the one where current VM will be. This is wrong assumsion,
      // but if I fix the formula I get less points...
      if (cost + u.ram >= (1 << srv.penalties) * srv.total_vms)
        continue;
      // Move VM and update information about servers.
      steps[u.home]++;
      steps[j]++;
      int source = VMS[i].home;
      servers[source].free_cpu += VMS[i].cpu;
      servers[source].free_ram += VMS[i].ram;
      servers[source].cpu_usage -= VMS[i].cpu_usage;
      servers[source].total_vms--;
      reallocations[i] = j;
      servers[j].free_cpu -= VMS[i].cpu;
      servers[j].free_ram -= VMS[i].ram;
      servers[j].cpu_usage += VMS[i].cpu_usage;
      servers[j].total_vms++;
      break;
    }
  }
  // Return generated reallocation scheme.
  return reallocations;
}

// Find cost for specified reallocation if it is left still for eight time
// points.
int get_reallocation_cost(std::vector<int> &reallocation) {
  int cost = 0;
  std::vector<int64_t> cpu_usage(NUMBER_OF_SERVERS);
  std::vector<int> vms(NUMBER_OF_SERVERS);
  for (int i = 0; i < NUMBER_OF_VMS; i++) {
    int j = reallocation[i];
    vms[j]++;
    cpu_usage[j] += VMS[i].cpu_usage;
    // Also include cost for moving VMs.
    if (j != VMS[i].home)
      cost += VMS[i].ram;
  }
  // Cost for servers is sum of costs for every server
  for (int j = 0; j < NUMBER_OF_SERVERS; j++)
    if (cpu_usage[j] > SERVERS[j].total_cpu * CPU_LIMIT)
      // 255 = 1 + 2 + 4 + ... + 128 -- cost for a few time points
      cost += (255 << SERVERS[j].penalties) * vms[j];
  return cost;
}

// Generate 100 random reallocations and choose the most cheap of them
std::vector<int> get_best_reallocation_scheme() {
  auto best_realocation = get_relocation_candidate();
  int best_cost = get_reallocation_cost(best_realocation);
  for (int i = 1; i < 100; i++) {
    auto candidate = get_relocation_candidate();
    int current_cost = get_reallocation_cost(candidate);
    if (current_cost < best_cost) {
      best_realocation = candidate;
      best_cost = current_cost;
    }
  }
  return best_realocation;
}

// Move VMs and output their movings
void reallocate_vms(int next_time_point) {
  auto next_homes = get_best_reallocation_scheme();
  std::vector<std::pair<int, int>> reallocation_list;
  for (int i = 0; i < NUMBER_OF_VMS; i++)
    if (next_homes[i] != VMS[i].home)
      reallocation_list.push_back(move_vm(i, next_homes[i]));
  std::cout << reallocation_list.size();
  for (auto reallocation : reallocation_list)
    std::cout << " " << reallocation.first << " " << reallocation.second;
  std::cout << std::endl;
}

// Comparator to sort VMs by their number of CPUs
bool cmp(VirtualServer &a, VirtualServer &b) {
  // Comparator should implement strict inequality, but my doesn't.
  // In other words this is undefined behavior, but I won't fix it,
  // since in this case the behavior is "get more points"
  return a.cpu >= b.cpu;
}

// Read input and update information in global variables.
void update_statistics() {
  int cpu_usages[10000];
  for (int i = 0; i < NUMBER_OF_VMS; i++)
    std::cin >> cpu_usages[i];
  for (int i = 0; i < NUMBER_OF_VMS; i++) {
    int cpu_usage = cpu_usages[VMS[i].id] * VMS[i].cpu;
    VMS[i].max_cpu_usage = std::max(VMS[i].max_cpu_usage, cpu_usage);
    int delta = cpu_usage - VMS[i].cpu_usage;
    VMS[i].cpu_usage += delta;
    SERVERS[VMS[i].home].cpu_usage += delta;
  }
  for (int i = 0; i < NUMBER_OF_SERVERS; i++) {
    auto &srv = SERVERS[i];
    if (srv.cpu_usage > srv.total_cpu * CPU_LIMIT) {
      TOTAL_PENALTY += std::pow(2.0, srv.penalties++) * srv.total_vms;
    }
  }
}

// The main!
int main() {
  // Read first section of the input
  std::ios::sync_with_stdio(false);
  std::cin >> NUMBER_OF_SERVERS >> NUMBER_OF_VMS >> NUMBER_OF_TIME_POINTS;
  assert(NUMBER_OF_SERVERS <= 100);
  assert(NUMBER_OF_VMS <= 10000);
  assert(NUMBER_OF_TIME_POINTS == 432 or NUMBER_OF_TIME_POINTS == 5);
  for (int i = 0; i < NUMBER_OF_SERVERS; i++) {
    std::cin >> SERVERS[i].free_cpu >> SERVERS[i].free_ram;
    SERVERS[i].total_cpu = SERVERS[i].free_cpu;
  }
  for (int i = 0; i < NUMBER_OF_VMS; i++)
    std::cin >> VMS[i].cpu >> VMS[i].ram;
  for (int i = 0; i < NUMBER_OF_VMS; i++) {
    int parent;
    std::cin >> parent;
    VMS[i].id = i;
    VMS[i].home = --parent;
    SERVERS[parent].free_cpu -= VMS[i].cpu;
    SERVERS[parent].free_ram -= VMS[i].ram;
    SERVERS[parent].total_vms++;
  }
  // Read information about first time point.
  update_statistics();
  // Sort VMs by cpu number.
  std::sort(VMS, VMS + NUMBER_OF_VMS - 1, cmp);
  // Reallocate VMs and read time point 431 times
  for (int time = 1; time < NUMBER_OF_TIME_POINTS; time++) {
    reallocate_vms(time);
    update_statistics();
  }
}
